<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexa - Handwritten Digit Recognition</title>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            text-align: center;
        }

        h1 {
            font-size: 36px;
            margin-bottom: 10px;
            color: #333;
        }

        .subtitle {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }

        canvas {
            border: 1px solid #000;
            cursor: crosshair;
        }

        button {
            margin: 10px;
            padding: 10px 20px;
        }

        #result {
            margin-top: 20px;
            font-size: 18px;
        }

        .nn-container {
            margin: 20px auto;
            max-width: 1200px;
            padding: 30px;
            background: #1a1a1a;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .nn-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #fff;
        }

        .nn-visualization {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            position: relative;
            min-height: 500px;
        }

        .input-image-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .input-image-box {
            width: 120px;
            height: 120px;
            background: #000;
            border: 2px solid #444;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .input-image-box img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .input-size-label {
            font-size: 14px;
            color: #aaa;
            font-weight: bold;
        }

        .layer-arrow {
            font-size: 32px;
            color: #666;
            margin: 0 10px;
        }

        .nn-layer-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .layer-label {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #aaa;
            text-align: center;
        }

        .layer-nodes {
            display: flex;
            flex-direction: column;
            gap: 3px;
            align-items: center;
            position: relative;
        }

        .neuron {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #333;
            border: 1px solid #555;
            transition: all 0.4s ease;
            position: relative;
        }

        .neuron.active {
            background: #fff;
            border-color: #fff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
        }

        .neuron.semi-active {
            background: #888;
            border-color: #aaa;
        }

        .neuron.inactive {
            background: #333;
            border-color: #555;
        }

        .connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 0.5;
            transition: stroke 0.3s;
        }

        .connection-line.active {
            stroke: rgba(255, 255, 255, 0.4);
            stroke-width: 1;
        }

        .output-layer-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }

        .output-neuron-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .output-neuron {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #333;
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: #aaa;
            transition: all 0.5s ease;
            flex-shrink: 0;
        }

        .output-neuron.predicted {
            background: #fff;
            border-color: #fff;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.9);
            transform: scale(1.2);
        }

        .output-neuron.active {
            background: #666;
            border-color: #888;
            color: #fff;
        }

        .output-prob {
            font-size: 14px;
            color: #aaa;
            font-weight: bold;
            min-width: 50px;
            text-align: left;
            transition: color 0.3s;
        }

        .output-neuron-wrapper.predicted .output-prob {
            color: #fff;
            font-size: 16px;
        }

        .layer-ellipsis {
            color: #666;
            font-size: 14px;
            margin: 5px 0;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .processing {
            animation: pulse 1s infinite;
        }

        @keyframes flow {
            0% {
                opacity: 0.2;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.2;
            }
        }

        .neuron.flowing {
            animation: flow 1s infinite;
        }
    </style>
</head>

<body>
    <h1>mojiâœ¨</h1>
    <div class="subtitle">
        <strong>how it works:</strong> draw a digit on the canvas below. When you click "Predict",
        your 28Ã—28 pixel image is sent to a CNN model trained on 60,000 handwritten digits from the MNIST dataset.
        The model uses two convolutional layers (with 32 and 64 filters) to detect edge patterns and shapes,
        two pooling layers to compress spatial information, then flattens and passes through two fully-connected layers
        (128 -> 10 neurons) to produce confidence scores for each digit (0-9). The digit with the highest confidence is
        returned as the prediction.
        so go ahead, draw a digit and see if moji can recognize it!ðŸ’«
    </div>
    <canvas id="canvas" width="300" height="300"></canvas><br>
    <button id="predictBtn">Predict</button>
    <button id="clearBtn">Clear</button>
    <div id="result"></div>

    <div class="nn-container" id="nnContainer" style="display: none;">
        <div class="nn-title">Neural Network Simulation</div>
        <div class="nn-visualization">
            <!-- Input Image -->
            <div class="input-image-container">
                <div class="input-image-box" id="inputImageBox">
                    <img id="inputImage" src="" alt="Input digit"
                        style="display: none; width: 100%; height: 100%; object-fit: contain;">
                </div>
                <div class="input-size-label">784</div>
            </div>

            <div class="layer-arrow">â†’</div>

            <!-- Input Layer (784 nodes) -->
            <div class="nn-layer-container">
                <div class="layer-label">Input Layer<br>(784)</div>
                <div class="layer-nodes" id="inputLayer"></div>
            </div>

            <div class="layer-arrow">â†’</div>

            <!-- Hidden Layer 1 (128 nodes) -->
            <div class="nn-layer-container">
                <div class="layer-label">Hidden Layer 1<br>(128)</div>
                <div class="layer-nodes" id="hiddenLayer1"></div>
            </div>

            <div class="layer-arrow">â†’</div>

            <!-- Hidden Layer 2 (64 nodes) -->
            <div class="nn-layer-container">
                <div class="layer-label">Hidden Layer 2<br>(64)</div>
                <div class="layer-nodes" id="hiddenLayer2"></div>
            </div>

            <div class="layer-arrow">â†’</div>

            <!-- Output Layer (10 nodes) -->
            <div class="nn-layer-container">
                <div class="layer-label">Output Layer<br>(10)</div>
                <div class="output-layer-container" id="outputLayer"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const predictBtn = document.getElementById('predictBtn');
        const clearBtn = document.getElementById('clearBtn');
        const resultDiv = document.getElementById('result');
        const nnContainer = document.getElementById('nnContainer');
        const inputImage = document.getElementById('inputImage');
        const inputImageBox = document.getElementById('inputImageBox');
        const inputLayer = document.getElementById('inputLayer');
        const hiddenLayer1 = document.getElementById('hiddenLayer1');
        const hiddenLayer2 = document.getElementById('hiddenLayer2');
        const outputLayer = document.getElementById('outputLayer');

        // Initialize neural network visualization
        function initNNVisualization() {
            // Create input layer (784 nodes - show 20 with ellipsis)
            inputLayer.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron inactive';
                inputLayer.appendChild(neuron);
            }
            const ellipsis1 = document.createElement('div');
            ellipsis1.className = 'layer-ellipsis';
            ellipsis1.textContent = '...';
            inputLayer.appendChild(ellipsis1);
            for (let i = 0; i < 10; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron inactive';
                inputLayer.appendChild(neuron);
            }

            // Create hidden layer 1 (128 nodes - show 20 with ellipsis)
            hiddenLayer1.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron inactive';
                hiddenLayer1.appendChild(neuron);
            }
            const ellipsis2 = document.createElement('div');
            ellipsis2.className = 'layer-ellipsis';
            ellipsis2.textContent = '...';
            hiddenLayer1.appendChild(ellipsis2);
            for (let i = 0; i < 10; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron inactive';
                hiddenLayer1.appendChild(neuron);
            }

            // Create hidden layer 2 (64 nodes - show 20 with ellipsis)
            hiddenLayer2.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron inactive';
                hiddenLayer2.appendChild(neuron);
            }
            const ellipsis3 = document.createElement('div');
            ellipsis3.className = 'layer-ellipsis';
            ellipsis3.textContent = '...';
            hiddenLayer2.appendChild(ellipsis3);
            for (let i = 0; i < 10; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron inactive';
                hiddenLayer2.appendChild(neuron);
            }

            // Create output layer (10 digits)
            outputLayer.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'output-neuron-wrapper';

                const neuron = document.createElement('div');
                neuron.className = 'output-neuron inactive';
                neuron.textContent = i;

                const prob = document.createElement('div');
                prob.className = 'output-prob';
                prob.textContent = '0%';

                wrapper.appendChild(neuron);
                wrapper.appendChild(prob);
                outputLayer.appendChild(wrapper);
            }
        }

        function resetNNVisualization() {
            // Reset input image
            inputImage.style.display = 'none';

            // Reset all neurons
            const allNeurons = document.querySelectorAll('.neuron, .output-neuron');
            allNeurons.forEach(n => {
                n.classList.remove('active', 'semi-active', 'predicted', 'flowing');
                n.classList.add('inactive');
            });

            // Reset output layer wrappers and probabilities
            const outputWrappers = outputLayer.querySelectorAll('.output-neuron-wrapper');
            outputWrappers.forEach(wrapper => {
                wrapper.classList.remove('predicted');
                const neuron = wrapper.querySelector('.output-neuron');
                const probElement = wrapper.querySelector('.output-prob');
                if (neuron) {
                    neuron.classList.remove('active', 'predicted');
                    neuron.classList.add('inactive');
                }
                if (probElement) {
                    probElement.textContent = '0%';
                }
            });
        }

        function animateNNVisualization(probabilities, imageData) {
            // Show input image
            inputImage.src = imageData;
            inputImage.style.display = 'block';

            // Animate input layer (784 nodes)
            setTimeout(() => {
                const neurons = inputLayer.querySelectorAll('.neuron');
                neurons.forEach((n, i) => {
                    setTimeout(() => {
                        n.classList.remove('inactive');
                        n.classList.add('active', 'flowing');
                        setTimeout(() => n.classList.remove('flowing'), 1000);
                    }, i * 20);
                });
            }, 200);

            // Animate hidden layer 1 (128 nodes)
            setTimeout(() => {
                const neurons = hiddenLayer1.querySelectorAll('.neuron');
                neurons.forEach((n, i) => {
                    setTimeout(() => {
                        n.classList.remove('inactive');
                        n.classList.add('semi-active', 'flowing');
                        setTimeout(() => {
                            n.classList.remove('flowing');
                            n.classList.add('active');
                        }, 500);
                    }, i * 15);
                });
            }, 1000);

            // Animate hidden layer 2 (64 nodes)
            setTimeout(() => {
                const neurons = hiddenLayer2.querySelectorAll('.neuron');
                neurons.forEach((n, i) => {
                    setTimeout(() => {
                        n.classList.remove('inactive');
                        n.classList.add('semi-active', 'flowing');
                        setTimeout(() => {
                            n.classList.remove('flowing');
                            n.classList.add('active');
                        }, 500);
                    }, i * 15);
                });
            }, 2000);

            // Animate output layer (10 digits)
            setTimeout(() => {
                const wrappers = outputLayer.querySelectorAll('.output-neuron-wrapper');
                const maxProb = Math.max(...probabilities);
                const predictedIndex = probabilities.indexOf(maxProb);

                wrappers.forEach((wrapper, i) => {
                    const prob = probabilities[i] || 0;
                    const neuron = wrapper.querySelector('.output-neuron');
                    const probElement = wrapper.querySelector('.output-prob');

                    setTimeout(() => {
                        if (neuron) {
                            neuron.classList.remove('inactive');
                            neuron.classList.add('active');
                        }

                        if (probElement) {
                            probElement.textContent = (prob * 100).toFixed(1) + '%';
                        }

                        if (i === predictedIndex) {
                            setTimeout(() => {
                                if (neuron) {
                                    neuron.classList.add('predicted');
                                }
                                wrapper.classList.add('predicted');
                            }, 300);
                        }
                    }, i * 100);
                });
            }, 3000);
        }

        // Initialize on page load
        initNNVisualization();

        let drawing = false;
        let lastX = 0;
        let lastY = 0;

        // Set canvas background to white
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Set drawing properties
        ctx.lineWidth = 15;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = 'black';

        // Mouse events for drawing
        canvas.addEventListener('mousedown', (e) => {
            drawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        });

        canvas.addEventListener('mouseup', () => drawing = false);
        canvas.addEventListener('mouseout', () => drawing = false);
        canvas.addEventListener('mousemove', draw);

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            drawing = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastX = touch.clientX - rect.left;
            lastY = touch.clientY - rect.top;
        });

        canvas.addEventListener('touchend', () => drawing = false);
        canvas.addEventListener('touchcancel', () => drawing = false);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!drawing) return;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawLine(lastX, lastY, x, y);
            lastX = x;
            lastY = y;
        });

        function drawLine(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function draw(event) {
            if (!drawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            drawLine(lastX, lastY, x, y);
            lastX = x;
            lastY = y;
        }

        // Clear canvas
        clearBtn.addEventListener('click', () => {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            resultDiv.textContent = '';
            nnContainer.style.display = 'none';
            resetNNVisualization();
        });

        // Determine backend URL
        const getBackendURL = () => {
            // Use current host if on a deployed Railway app (railway.app domain)
            if (window.location.hostname.includes('railway.app')) {
                return `https://${window.location.host}`;
            }
            // Use localhost for development
            return 'http://127.0.0.1:8080';
        };

        const BACKEND_URL = getBackendURL();

        // Check if backend is running
        async function checkBackend() {
            try {
                const response = await fetch(`${BACKEND_URL}/health`);
                const data = await response.json();
                if (!data.model_loaded) {
                    resultDiv.textContent = 'Warning: Model not loaded. Please train the model first.';
                    resultDiv.style.color = 'orange';
                }
            } catch (error) {
                resultDiv.textContent = 'Error: Backend server is not running. Please start the backend with: python backend.py';
                resultDiv.style.color = 'red';
            }
        }

        // Check backend on page load
        checkBackend();

        // Predict
        predictBtn.addEventListener('click', async () => {
            const imageData = canvas.toDataURL('image/png');
            resultDiv.textContent = 'Processing...';
            resultDiv.style.color = 'black';

            // Reset and show neural network visualization
            resetNNVisualization();
            nnContainer.style.display = 'block';

            try {
                const response = await fetch(`${BACKEND_URL}/predict`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: imageData })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: `Server error: ${response.status}` }));
                    resultDiv.textContent = `Error: ${errorData.error || response.statusText}`;
                    resultDiv.style.color = 'red';
                    nnContainer.style.display = 'none';
                    return;
                }

                const data = await response.json();
                if (data.error) {
                    resultDiv.textContent = `Error: ${data.error}`;
                    resultDiv.style.color = 'red';
                    nnContainer.style.display = 'none';
                } else {
                    resultDiv.textContent = `Prediction: ${data.digit} (Confidence: ${(data.confidence * 100).toFixed(2)}%)`;
                    resultDiv.style.color = 'green';

                    // Animate neural network with probabilities
                    if (data.probabilities) {
                        animateNNVisualization(data.probabilities, imageData);
                    }
                }
            } catch (error) {
                if (error.message === 'Failed to fetch') {
                    resultDiv.textContent = `Error: Cannot connect to backend at ${BACKEND_URL}`;
                } else {
                    resultDiv.textContent = `Error: ${error.message}`;
                }
                resultDiv.style.color = 'red';
                nnContainer.style.display = 'none';
            }
        });
    </script>
</body>

</html>